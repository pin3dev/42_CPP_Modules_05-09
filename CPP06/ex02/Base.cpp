/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Base.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pin3dev <pinedev@outlook.com>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/02/22 14:51:18 by pin3dev           #+#    #+#             */
/*   Updated: 2024/03/18 09:04:21 by pin3dev          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Base.hpp"
#include "A.hpp"
#include "B.hpp"
#include "C.hpp"



/**
 * @brief This is the Base class destructor
 * 
 * @note This destructor is virtual to allow the derived classes to have their additional destructors called
*/
Base::~Base()
{
	std::cout << BKGRAY "[Base] Destructor called" RESET << std::endl;
}

/**
 * @brief This function is responsible for generating a random pointer to Base class (upcasting the A, B or C class to Base)
 * @warning Verify if the pseudo-random number generated is:
 * 			- divisible by 3 EXEMPLE: (3, 6, 9, 12, 15, 18, 21, 24, 27, 30)
 * 			- or if is divisible by 3 and has a remainder of 1 EXEMPLE: (1, 4, 7, 10, 13, 16, 19, 22, 25, 28)
 * 			- or if is another case EXEMPLE: (2, 5, 8, 11, 14, 17, 20, 23, 26, 29)
 * @return a random pointer to inherit from the Base class (A, B or C)
 * 
 * @note the rand() function is used to generate a pseudo-random number
 * @note if the rand() dont receive a seed, it will generate the same number every time
 * @note the seed is set to time(0) to generate a different number every time, 
 * 		 based on the current time counting from January 1, 1970
*/
Base* generate()
{
	srand(time(0));
	int n = rand();
	if (n % 3 == 0)
		return (new A);
	else if (n % 3 == 1)
		return (new B);
	return (new C);
}

//TODO - VERIFICAR SE EXPLICAÇÃO TA CORRETA

/**
 * @brief This function is responsible for identifying one pointer to Base class
 * @param p a pointer to Base class
 * 
 * @warning if the pointer is an instance of the class, it will print the class name
 * 			if the pointer is not an instance of the class, it will print "Unknown pointer"
 * 
 * @note the dynamic_cast is used to check if the pointer is an instance of a inherited class of Base
 * @note the signature dynamic_cast<AnyClass*>(p) try to cast the pointer to the AnyClass class
 * 		 if the pointer is an instance of the AnyClass class, the dynamic_cast will return a pointer to the AnyClass class
 * 		 filling as none-zero the condition, so the "if" block will be executed
 *  	 otherwise, the dynamic_cast will return a nullptr, filling as zero the condition
 * @note the dynamic_cast if available in execution time (read more about RTTI), so it will be able to check the pointer type,
 *    	 otherwise, the static_cast is available in compile time, so it will not be able to check the pointer type
 * @note in this case, the pointer p will be generated by the generate() function randomly,
 * 		 so the best and safe way to check the pointer is using the dynamic_cast.
*/
void	identify(Base *p)
{
	if (dynamic_cast<A*>(p))
		std::cout << GREEN "A pointer" RESET << std::endl;
	else if (dynamic_cast<B*>(p))
		std::cout << GREEN "B pointer" RESET << std::endl;
	else if (dynamic_cast<C*>(p))
		std::cout << GREEN "C pointer" RESET << std::endl;
	else
		std::cerr << RED "Unknown pointer" RESET << std::endl;
}


/**
 * @brief This function is responsible for identifying one reference to Base class
 * @param p a reference to Base class
 * 
 * @warning if the reference is an instance of the class, it will print the class name
 * 
 * @warning as reference could not be a nullptr, the dynamic_cast will throw a std::bad_cast exception
 *     		that is why the try/catch block is used to catch and deal with the exception
 * 
 * @warning the use of (void) is to avoid the "unused" warning by Wall Wextra Werror compilation flags,
 *   		and to enfatize that the return of the dynamic_cast is not used, but the exception is
 * 
 * @note the dynamic_cast is used to check if the reference is an instance of a inherited class of Base
 * @note the signature dynamic_cast<AnyClass&>(p) try to cast the reference to the AnyClass class
 * 		 if the pointer is an instance of the AnyClass class, the dynamic_cast will return a reference to the AnyClass class
 * 		 filling as none-zero the condition, so the "if" block will be executed,
 * 		 otherwise, the dynamic_cast will throw a std::bad_cast exception
 * @note the dynamic_cast if available in execution time (read more about RTTI), so it will be able to check the pointer type,
 *    	 otherwise, the static_cast is available in compile time, so it will not be able to check the pointer type
*/
void	identify(Base &p)
{
	try
	{
		(void)dynamic_cast<A&>(p);
		std::cout << GREEN "A ref" RESET << std::endl;
	}
	catch (std::bad_cast &e) {}
	try
	{
		(void)dynamic_cast<B&>(p);
		std::cout << GREEN "B ref" RESET << std::endl;
	}
	catch (std::bad_cast &e) {}
	try
	{
		(void)dynamic_cast<C&>(p);
		std::cout << GREEN "C ref" RESET << std::endl;
	}
	catch (std::bad_cast &e) {}
}
